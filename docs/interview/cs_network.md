# 计算机网络

## HTTP2.0 之前的发展

### HTTP/0.9

- 只有 GET 命令，没有 HEADER 等描述数据的信息。

### HTTP/1.0

- 增加了很多命令，如 POST、PUT 等。

- 增加了状态码和 HEADER 相关信息。

- 增加了缓存。

### HTTP/1.1

- 持久连接，不会关闭 TCP 连接。

- 增加了 pipeline，可以在同⼀个 TCP 连接⾥⾯发送多个 http 请求，不过这是串⾏的。

- 增加了头部 host，即可以在同⼀台服务器(物理服务器)上同时跑多个 web 服务。

## HTTP2.0 特性

### 头部信息压缩

在 HTTP2.0 中，使用了 HPACK（HTTP2 头部压缩算法）压缩格式对传输的 header 进行编码，减少了 header 的大小。

同时在两端维护索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 键名，对端收到数据之后，就可以通过键名找到对应的值。

### 推送功能

在请求 html 的同时，服务器端可以主动把 html 里面所引用到的 css 和 js 文件推送到客户端，这样 html、css、js 的发送就是并行而不是串行的，整体的传输效率和性能得到提高。

在 HTTP2.0 中，服务器可以对一个客户端的请求发送多个响应。如果客户端发送了一个请求，服务器可能会响应网页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这样不但减少了数据传送的冗余步骤，也加快了页面的响应速度，提高了用户体验。

推送功能的限制：服务器主动推送的资源必须遵守同源策略。也就是说，服务器不能随便将第三方的资源推送给客户端，而必须经过双方的确认才行。

### 二进制分帧

所有传输的数据都会被分割，并采⽤⼆进制格式编码。

### 多路复用

在 HTTP1.x 中，我们经常会使用雪碧图、使用多个域名等方式来进行优化，这是因为浏览器限制了同一个域名下的请求数量。当页面需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求时，资源需要等待其它资源请求完成后才能继续发送。

HTTP2.0 中，基于二进制分帧层，HTTP2.0 可以在共享 TCP 连接的基础上同时发送请求和响应。

HTTP 消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去。另一端根据流标识符和首部将它们重新组装起来。通过该技术，可以避免 HTTP 旧版本的队头阻塞问题，提高传输性能。

#### 如何确认优先级？

把 HTTP 消息分为很多独立帧后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。

HTTP2.0 中，不同浏览器拥有不同的优先级树，对于不同的资源优先级会不同。例如，html、css、阻塞性js、影响 LCP 等指标的图片的优先级会比较高，并且优先级并不是静态不变的。

在 HTTP3 中进行了统一，取消了优先级树，建立 8 个等级的优先级表，支持自定义优先级。不过不同浏览器还是存在不同的资源优先级表现。

## HTTP 持久连接

HTTP1.0 协议中并未定义持久连接的实现方式，但是一些服务端和客户端开始使用了这种方式进行持久连接。

如果浏览器支持 `keep-alive`，它会在请求头中添加 `Connection: Keep-Alive`，服务器收到请求，作出响应的时候，它也会在响应头中添加相同的 HTTP 头部。

在完成响应之后的一段时间内会保持 TCP 连接。客户端知道服务端支持持久连接，因此在发送另一个请求时，会直接使用同一个连接发送请求。这种持久连接将一直保持，直到客户端或服务端认为无需继续维持时主动中断连接，或者使用 `Connection: close` 字段通知对方可以关闭连接。

在 HTTP1.1 中，默认所有连接都是持续连接，除非任意一方在请求的时候明确声明不支持持久连接。HTTP1.1 的持久连接不需要使用独立的 keep-alive 信息，但是处于兼容性考虑，实现上通常还是会像 HTTP1.0 一样添加 `Connection: Keep-Alive` 字段。

HTTP2.0 协议要求双⽅必须⽀持复⽤连接。HTTP3.0 因为使⽤基于 UDP 的 QUIC 协议，故此不存在“连接”的概念，⾃然⽆需提供持久连接。

持久连接的不足：

持久连接只有在客户端需要发送多于一个请求时才能发挥优势。在客户端只需要发起一个请求的场景下，持久连接会导致客户端请求完成之后的一段时间内，仍然与服务端保持不必要的连接，反而导致性能下降。

## HTTP 状态码

### 总览

| 状态码 | 代表状态                | 含义                     |
| ------ | ----------------------- | ------------------------ |
| 1xx    | information 信息        | 请求正在处理             |
| 2xx    | success 成功            | 请求成功                 |
| 3xx    | redirection 重定向      | 需要进行附加操作完成请求 |
| 4xx    | client error 客户端错误 | 客户端出错               |
| 5xx    | server error 服务端错误 | 服务端出错               |

### 4xx

| 状态码                     | 含义                                                                                         |
| -------------------------- | -------------------------------------------------------------------------------------------- |
| 400 Bad Request            | 请求报文存在语法错误，需修改再次发送                                                         |
| 401 Unauthorized           | 发送的请求需要有通过 HTTP 认证的认证信息或认证失败                                           |
| 403 Forbidden              | 服务器拒绝访问。**跨域**访问、未获得文件系统的访问授权、从未授权的 IP 发送请求都可能返回 403 |
| 404 Not Found              | 找不到请求的资源                                                                             |
| 415 Unsupported Media Type | 服务器无法处理请求附带的媒体格式，通过添加 `content-type` 请求头指明数据类型                 |

400 一般是两种情况：

- 前端传的参数类型或者名称与后台接收参数的实体类的属性类型或者名称不一致
- 前端提交 ajax 请求的数据应该是 json 格式字符串的，但是却没有将对象转换成 json 格式的字符串

401 和 403 的区别：

- 401 指客户端没有认证或认证失败，可以修改认证信息重试
- 403 指客户端认证成功了，但没有资格访问资源，且在获得权限之前不用再重试了

### 5xx

| 状态码                         | 含义                                               |
| ------------------------------ | -------------------------------------------------- |
| 500 Internal Server Error      | 服务端内部错误                                     |
| 501 Not Implemented            | 服务端无法完成请求，如无法识别请求方法             |
| 502 Bad Gateway                | 网关错误，可能是服务器没开或压力太大响应不过来     |
| 503 Service Unavailable        | 服务端处于超负载状态或正停机维护，暂时无法处理请求 |
| 504 Gateway Time-out           | 网关超时                                           |
| 505 HTTP Version Not Supported | 服务端不支持 HTTP 协议的版本                       |

#### 相关链接

- [HTTP Status 400 (HTTP400 状态码)](https://blog.csdn.net/qq_22182643/article/details/103103078/)

- [401 与 403 的区别](https://blog.csdn.net/condoleeA/article/details/104589824/)

- [HTTP 状态码 401 和 403 深度解析](https://juejin.cn/post/6844903590763429895)

- [HTTP 请求返回 415 错误码定位解决](https://majing.blog.csdn.net/article/details/78383772)

- [HTTP 状态码 502 深度解析](https://blog.csdn.net/Xu_pengtao/article/details/122884259)

## webSocket

在 webSocket 出现之前，实现实时通讯采用轮询的方式，耗费了大量的带宽和 CPU 资源。webSocket 更侧重于实时通信，而 HTTP2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。websocket 不像 HTTP2 那样定义流，也就不存在多路复用、优先级等特性。

特点：

- 全双工、二进制帧、协议名（ws、wss）、握手（需要握手才能正式收发数据）。

- 握手的过程为：客户端发送的请求中包含了 Upgrade: websocketConnection: Upgrade，以及一个 base 编码的密文，用于简单的认证密钥。服务器返回 Upgrade: websocketConnection: Upgrade 表示接受 websocket 协议的客户端连接，返回一个密钥用于验证客户端请求报文，防止误连接。

优点：

- 较少的控制开销：数据包头部协议较小，不同于 HTTP 每次请求需要携带完整的头部。

- 更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少，允许服务端主动向客户端推送数据。

- 保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证。

- 更好的二进制支持：定义了二进制帧，更好处理二进制内容。

- 支持扩展：用户可以扩展 websocket 协议，实现部分自定义的子协议。

- 更好的压缩效果：websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。

应用：

- 弹幕

- 媒体聊天

- 协同编辑

- 基于位置的应用

- 体育实况更新

- 股票基金报价实时更新

[WebSocket 原理与应用](https://www.cnblogs.com/frank-link/p/14835705.html){link=static}